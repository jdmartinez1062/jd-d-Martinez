<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Fork Me! FCC: Test Suite Template</title>
    <link rel="stylesheet" href="css/style.css">
  </head>

  <body>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    <div>
      <header>
        <h1 id="title">Technical Documentation</h1>
      </header>
    </div>
  <main id= "main-doc">
      <nav id="navbar">
        <header>Microcontrollers Documentation</header>
        <ul>
          <li><a class="nav-link" href="#Introduction">Introduction</a></li>
          <li><a class="nav-link" href="#What_you_should_already_know">What you should already know</a></li>
          <li><a class="nav-link" href="#Programming_Microcontrollers">Programming Microcontrollers</a></li>
          <li><a class="nav-link" href="#Hello_world">Hello world</a></li>
          <li><a class="nav-link" href="#Data_sizes">Data sizes</a></li>
        </ul>
      </nav>
      <div>
      <section class="main-section" id="Introduction">
        <header>Introduction</header>
        <p>
          It is a known fact that requirements and needs lead to inventions and discoveries.
          Business at the Texas Instruments MOS Department was mostly a custom business wherein companies like desktop calculator manufacturers came to TI with a set of specific requirements. TI converted those specifications to a chip set, normally four, five or six chips to execute or implement the specifications for popular companies like Canon, Olympia or Olivetti.Â  For these companies, it was really amazing that TI provided this ultimate service of compressing so many units on to just four or five or six chips because the previously used technology called the TTL would use hundred to two hundred chips. No wonder the business was doing great.
        </p>
        <p>
          It was during these times that Gary Boone was with a few other people making extensive research within the country as well as flying to Germany, Italy and other countries. They were trying to understand the needs of the new customers and work on it. Boone was literally bored after doing this a number of times. Besides, since their previous projects were all successful and they had a flock of satisfied customers, a new set of customers required them to do the same work they did to someone else the previous year. Thus, there was a significant demand for more and more of these projects.
        </p>
        <ul>
          <li>ATMEL</li>
          <li>PIC</li>
          <li>TEXAS INSTRUMENTS</li>
          <li>ST MICROELECTRONICS</li>
        <li>ESPRESSIFF</li>
        </ul>
    </section>

      <section class="main-section" id="What_you_should_already_know">
        <header>What you should already know</header>
        <p>
          JavaScript and Java are similar in some ways but fundamentally different in some others. The JavaScript language resembles Java but does not have Java's static typing and strong type checking. JavaScript follows most Java expression syntax, naming conventions and basic control-flow constructs which was the reason why it was renamed from LiveScript to JavaScript.
          JavaScript is a very free-form language compared to Java. You do not have to declare all variables, classes, and methods. You do not have to be concerned with whether methods are public, private, or protected, and you do not have to implement interfaces. Variables, parameters, and function return types are not explicitly typed.
        </p>
        <p>
          In contrast to Java's compile-time system of classes built by declarations, JavaScript supports a runtime system based on a small number of data types representing numeric, Boolean, and string values. JavaScript has a prototype-based object model instead of the more common class-based object model. The prototype-based model provides dynamic inheritance; that is, what is inherited can vary for individual objects. JavaScript also supports functions without any special declarative requirements. Functions can be properties of objects, executing as loosely typed methods.
        </p>
      </section>

      <section class="main-section" id="Programming_Microcontrollers">
        <header>Programming Microcontrollers</header>
        <p>
          Before you can upload your program to your microcontroller, you need to compile it. This means converting the code from human-readable code to machine-readable code.
          Use a compiler that supports your microcontroller and compile your code into machine-code for your chip. A popular compiler for Atmel AVR microcontrollers is avr-gcc.
          After compilation, you will have one or more files containing machine code. Then you need to upload these files to your microcontroller.
         </p>
        <p>
          Usually, it’s one program file and a file for EEPROM and/or flash that you need to upload.
          You need a physical connection from your computer to your microcontroller. Either you can use a dedicated programmer (such as the AVRISP for AVR microcontrollers), or if you have a USB programmable chip you can program it with a USB cable (my preferred method).
          And you need a program for uploading the file(s). For AVR chips, you can use AVRDUDE.
        </p>
      </section>

      <section class="main-section" id="Hello_world">
        <header>Hello world</header>
        <p>
          GPIO pins are normally configured on reset as inputs, but they can be reconfigured under program control.  GPIO pin options can vary from a few simple choices (input or output) to a fairly complex set of choices.  The AVR family is on the simple side of the spectrum.  An AVR GPIO pin can be configured as an input or as an output.  Additionally, if a pin is configured as an input, it can further be configured to enable a weak internal pullup resistor on the input.  So the three choices are ouput, input, or input with internal pullup.
          For the STM32, there are many more options, including both internal pullups and internal pulldowns, as well as various output configurations, and speed ratings to offer tradeoffs between output switching speed and EMI (electromagnetic interference).  In addition, before using an STM32 GPIO port, that port's clock must be enabled.
          It is worth noting here that the AVR ports are 8 bits wide, while the STM32 ports are 12 bits wide.
        </p>
        <p>
          Embedded programs will typically do a fair amount of bit manipulation, both input and output. All kinds of switches, sensors, drivers, actuators, and other input and output devices are represented in the program as individual bits or collections of bits. Not only that, but a μC will have many configuration and status registers which will call for the setting or clearing of individual configuration bits, and the reading of individual status bits.
          In our first example programs we will see LEDs and switches represented as individual bits, and later many other input and output devices will be added to that list. Thus it is important to understand how to manipulate bits, that is, to read individual bit states and to set or clear individual bit states.
          What makes bit manipulation non-trivial is that bits do not usually exist alone, but exist within bytes (and 16-bit words and 32-bit words). Thus it becomes necessary, when writing individual bits, to avoid changing other bits within the same byte/word, and when reading individual bits, to avoid reading (or ignore) other bits within the same byte/word. The CPU logic instructions, as discussed in an earlier section, are what allow us to do these things.
          It must be noted that some μC families also include instructions that directly act on individual bits, at least individual bits in certain registers or address ranges. These instructions are commonly used for reading and writing bits in configuration and status registers, and for maintaining bit flags in memory. These instructions, while nice to have, are not a necessity, and the standard logic instructions can always do the same job (with one or two caveats that we will discuss in the future).  What's more, standard C and other high-level languages will not have language constructs designed to access individual bits, even if the μC does have individual bit instructions.  If you are writing in a high-level language, it will be up to your compiler as to whether it  recognizes individual bit manipulations and uses specialized instructions in those cases.
        </p>
      </section>

      <section class="main-section" id="Data_sizes">
        <header>Data sizes</header>
        <p>
          Before we start talking about time delays, this is probably as good a place as any to examine and emphasize the range of values that can be represented by data variables of different byte sizes.  These are numbers that μC programmers will deal with throughout their careers, so get to know them well:
          <br>
          <br>
          <code>
            • 1 byte (8 bits):    0 to 255 unsigned             -128 to 127 signed
          </code>
          <br>
          <code>
            • 2 bytes (16 bits):  0 to 65,535 unsigned          -32,768 to 32,767 signed
          </code>
          <br>
          <code>
            • 2 bytes (16 bits):  0 to 65,535 unsigned          -32,768 to 32,767 signed
          </code>
          <br>
          <code>
            • 2 bytes (16 bits):  0 to 65,535 unsigned          -32,768 to 32,767 signed
          </code>
          <br><code>
            • 4 bytes (32 bits):  0 to 4,294,967,295 unsigned   -2,147,483,678 to 2,147,483,677 signed
            (for 32 bits I just think 0 to 4 billion unsigned, -2 billion to +2 billion signed)
          </code>
          <br>

        </p>
        <p>
          While there are many ways to execute time delays and generate time intervals, the simplest (but not the best) is a software delay.  This just involves sitting in a do-nothing loop for the desired length of time, and then exiting the loop.  Since microcontrollers are so fast, a one-second delay may loop hundreds of thousands or millions of times.  These are hundreds of thousands or millions of CPU clock cycles that are being wasted, not available for doing any other useful work.  For this reason, software delays are not generally a good idea, even though they are easy to understand for beginners.
          For a suitable LED blink rate, a useful rule of thumb for estimating how many times a software delay should loop is to divide the μC clock rate by 100.  Use this count for both the LED ON and OFF times, so the total LED delay for one blink cycle is twice this value.  Thus an AVR running at 1MHz would delay loop 10,000 times while ON, then 10,000 times while OFF, and the STM32 running at 8MHz would delay loop 80,000 times ON and the same number OFF.  This is just a rule of thumb, of course, and the numbers can be increased or decreased, but it's a really easy number to calculate, and it generally gives a number that results in a good blink rate.  A good blink rate is simply one where the total blink period is not so small that the LED blinks too fast to notice it is blinking (say 20 or more times per second), nor so large that the LED takes many seconds to blink, forcing you to sit and stare at it to see if your program is working at all.
        </p>

      </section>
      <div>
    </main>
  </body>
